---
title: "Breast Cancer Biopsy Classification Project"
subtitle:  "Guy Leib (316311190), Shir Amit Fishbein (207640228), Nadav Klein (318865698)"
authors: Guy Leib, Shir Amit Fishbein, Nadav Klein
output: pdf_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r imports, include=FALSE}
library(ggplot2)
library(tidyverse)
library(patchwork)
library(dplyr) 
```
```{r}
#install.packages("GGally")
#install.packages("corrplot")
library(corrplot)
library(GGally)
library(plotly)
```


<Opening paragraph>

# The Data
Biopsy features for classification of 569 malignant (cancer) and benign (not cancer) breast masses.
Features were computationally extracted from digital images of fine needle aspirate biopsy slides.
## columns description
In each observation, 10 attributes were measured for *every cell* in the biopsy (see the list below).
Our data contain summery of those results and each row in the data contain only the mean, the standard error and the worst case among the cells (can be the larger or the most severe, depending the feature).
overall, the data contains 3*10 features and a label (column Y) that mention wherever the mass is malignant (M) or benign (B).
*list of the 10 measures:*
radius, texture, perimeter, area, smoothness, compactness, concavity, concave points, symmetry, fractal dimension.
radius: 	Nucleus radius (mean of distances from center to points on perimeter).
texture:	 Nucleus texture (standard deviation of grayscale values).
perimeter:	Nucleus perimeter.
area:	Nucleus area.
smoothness:	Smoothness of the tumor cells.
compactness:	 Nucleus compactness (perimeter^2/area - 1).
concavity:	Nucleus concavity (severity of concave portions of the contour).
concave_points:	Number of concave portions of the nucleus contour.
symmetry:	Nucleus Symmetry.
fractal_dimension: Nucleus fractal dimension ("coastline approximation" -1).


# Get started
## Upload and initial cleaning of the data
We are first changing the names of the columns and the labels from 'M' and 'B' to 'Malignant' and 'Benign'.
```{r load, message=FALSE, warning=FALSE, echo=FALSE}
brca <-read.csv("data//brca.csv")
```
```{r cleaning}
# remove the prefix "x." from column names
colnames(brca) <- gsub("^x\\.", "", colnames(brca))
colnames(brca)[which(names(brca) == "y")] <- "diagnosis"
# remove id column
brca<-brca[,-1]
# factorize the label
brca <- brca %>% mutate(diagnosis = if_else(diagnosis == "B", "Benign", "Malignant"))
brca$diagnosis <- as.factor(brca$diagnosis)
brca.x <- brca[,!(colnames(brca) %in% c("diagnosis"))]
colnames(brca)
```
## Show values range
Afterward, to examine our data, we want to see the ranges of the values within each column
```{r examine}
measures <- c("radius", "texture", "perimeter", "area", "smoothness", "compactness", "concavity", "concave_pts", "symmetry", "fractal_dim")
cat("Range of values in the numerical columns: \n")
for (prefix in measures) {
  # Find column names that start with the current prefix
  cat("-------", prefix, "-------\n")
  cat("\t\t\t min:\t\t max:\t\t mean:\n")
  prefix.mean <- paste0(prefix, "_mean")
  prefix.se <- paste0(prefix, "_se")
  prefix.worst <- paste0(prefix, "_worst")

  # Print the result
  cat("Mean:\t\t\t", round(min(brca[[prefix.mean]]), 2), "\t\t" , round(max(brca[[prefix.mean]]), 2), "\t\t", round(mean(brca[[prefix.mean]]) ,2), "\n")
  cat("Standard error:\t\t", round(min(brca[[prefix.se]]), 2), "\t\t" , round(max(brca[[prefix.se]]), 2), "\t\t", round(mean(brca[[prefix.se]]) ,2), "\n")
  cat("Worst:\t\t\t", round(min(brca[[prefix.worst]]), 2), "\t\t" , round(max(brca[[prefix.worst]]), 2), "\t\t", round(mean(brca[[prefix.worst]]) ,2), "\n")
}
cat("\n\nnumber of NAs in dataset: ",sum(is.na(brca)))
```

Above we see the ranges of the values in our data and that there are no missing values. all the features are numeric.
# Data cleaning
## Normalization
Because we have different ranges and we don't want that the scale of the feature will be a factor during the study we would like to normalize each column to values between 0 and 1 by preforming Min-Max normalization
```{r norm}
minmax <- function(x) {
return ((x - min(x)) / (max(x) - min(x)))
}
brca.x.normal <- as.data.frame(lapply(brca.x, minmax))
```
```{r show norm range}
for (prefix in measures) {
  # Find column names that start with the current prefix
  cat("-------", prefix, "-------\n")
  cat("\t\t\t min:\t\t max:\t\t mean:\n")
  prefix.mean <- paste0(prefix, "_mean")
  prefix.se <- paste0(prefix, "_se")
  prefix.worst <- paste0(prefix, "_worst")

  # Print the result
  cat("Mean:\t\t\t", round(min(brca.x.normal[[prefix.mean]]), 2), "\t\t" , round(max(brca.x.normal[[prefix.mean]]), 2), "\t\t", round(mean(brca.x.normal[[prefix.mean]]) ,2), "\n")
  cat("Standard error:\t\t", round(min(brca.x.normal[[prefix.se]]), 2), "\t\t" , round(max(brca.x.normal[[prefix.se]]), 2), "\t\t", round(mean(brca.x.normal[[prefix.se]]) ,2), "\n")
  cat("Worst:\t\t\t", round(min(brca.x.normal[[prefix.worst]]), 2), "\t\t" , round(max(brca.x.normal[[prefix.worst]]), 2), "\t\t", round(mean(brca.x.normal[[prefix.worst]]) ,2), "\n")
}
```

# Exploratory Data Analysis
## Balance
First, we want to see if the labels are balanced:
```{r}
df <- brca["diagnosis"] %>% 
  group_by(diagnosis) %>%
  count() %>% 
  ungroup() %>% 
  mutate(perc = `n` / sum(`n`)) %>% 
  arrange(perc) %>%
  mutate(labels = scales::percent(perc))

ggplot(df, aes(x = "", y = perc, fill = diagnosis)) +
  geom_col() +
  geom_label(aes(label = labels),
             position = position_stack(vjust = 0.5),
             show.legend = FALSE) +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
  coord_polar(theta = "y")
```
We can see that the data doesn't contain significant bias toward one of the labels.
it is possible that it could effect on the results but from the other hand we don't want to lose data that can be significant.
therefore, considering that the bias is not very large, we decided to not make changes.

## distributions differences
We want to explore if we can see visually how the measures are related to the diagnosis,
we create box plots to each aspect of each measure for both labels - Benign and Malignant.
```{r mean plot}
box_df <- as_tibble(brca.x.normal) %>%
  select(ends_with("_mean")) %>%
  rename_all(~ str_replace_all(., "_mean", "")) %>%
  mutate(brca["diagnosis"]) %>%
  pivot_longer(col = -diagnosis, names_to = "features", values_to = "value")
p.mean <- ggplot(box_df,
       aes(factor(features,levels = measures),
           value, fill = diagnosis)) +
  geom_boxplot() +
  scale_fill_manual(values = c("#75c731", "#0488cf")) +
  labs(x = "Feature (mean)", y = "Standardized value") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(size = 7))
p.mean + plot_annotation(title = "Mean values distribution")
```
```{r se plot}
box_df <- as_tibble(brca.x.normal) %>%
  select(ends_with("_se")) %>%
  rename_all(~ str_replace_all(., "_se", "")) %>%
  mutate(brca["diagnosis"]) %>%
  pivot_longer(col = -diagnosis, names_to = "features", values_to = "value")
p.mean <- ggplot(box_df,
       aes(factor(features,levels = measures),
           value, fill = diagnosis)) +
  geom_boxplot() +
  scale_fill_manual(values = c("#75c731", "#0488cf")) +
  labs(x = "Feature (standard error)", y = "standardized value") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(size = 7))
p.mean + plot_annotation(title = "Standard error values distribution")
```
```{r worst plot}
box_df <- as_tibble(brca.x.normal) %>%
  select(ends_with("_worst")) %>%
  rename_all(~ str_replace_all(., "_worst", "")) %>%
  mutate(brca["diagnosis"]) %>%
  pivot_longer(col = -diagnosis, names_to = "features", values_to = "value")
p.mean <- ggplot(box_df,
       aes(factor(features,levels = measures),
           value, fill = diagnosis)) +
  geom_boxplot() +
  scale_fill_manual(values = c("#75c731", "#0488cf")) +
  labs(x = "Feature (worst)", y = "standardized value") +
  theme_minimal(base_size = 12) +
  theme(axis.text.x = element_text(size = 7))
p.mean + plot_annotation(title = "Worst values distribution")
```
We see from the plots that the features are indeed related to the diagnosis, but that a single feature cannot predict the label alone.
Our challenge during this work will be to combine the features in a way that will give the best prediction.


# Feture selection
Because the nature of our data, having 3 aspects of every feature, there might be biases while applying VM models using all the features, where there can be duplicates in the trends between them.
moreover, the "worst" columns are often in correlation with the "mean" and the "se" of the same measure. [see supplement figures]
To overcome this, we apply PCA on each triplet of "mean", "se" and "worst" and create new data-frame with columns of the PCs (until 95% contribution of variables) instead of the whole triplets.
In addition, even between the different measures, we can find duplicates:
The radius of a cell has strong correlation to it's perimeter and area [also in the supplement figures].
To present our claim here is the correlations between all the features:
```{r corr before pca}
corrs <- cor(brca.x.normal)
colnames(corrs) <- gsub("_", " ", colnames(corrs))
rownames(corrs) <- gsub("_", " ", rownames(corrs))
corrplot(corrs, method = "square", tl.col = "black", tl.srt = 45, sig.level = 0.05, type = 'lower', diag = FALSE)
```
To overcome this, we:
1) preform PCA on all the aspects of the features "radius", "perimeter" and "area":
```{r pca shape}
mesures.shape <- c("radius", "perimeter", "area")
measures <- c("texture","smoothness", "compactness", "concavity", "concave_pts", "symmetry", "fractal_dim")
shape <- c()
for (prefix in mesures.shape) {
  # Find column names that start with the current prefix
  shape <- append(shape,paste0(prefix, "_mean"))
  shape <- append(shape,paste0(prefix, "_se"))
  shape <- append(shape,paste0(prefix, "_worst"))
}
brca.shape <- brca.x.normal[,shape]
pca <- prcomp(brca.shape)
summary(pca)
```
By taking PC1 and PC2 alone (instead all the 6 features) we can explain nearly 98% of the variance.
therefore, we will create 2 new features: "shape_pc1" and "shape_pc2" instead the previous ones.
```{r}
brca.reduced <- data.frame(brca[,c('diagnosis')])
colnames(brca.reduced) <- c("diagnosis")
brca.reduced$shape_pc1 <- pca$x[,1]
brca.reduced$shape_pc2 <- pca$x[,2]
```
2) preform PCA on every triplet of "mean", "standard error" and "worst".
we replace the original features with PC1 and PC2 if they can explain more than 95% of the variance.
```{r}
for (prefix in measures) {
  # Find column names that start with the current prefix
  prefix.mean <- paste0(prefix, "_mean")
  prefix.se <- paste0(prefix, "_se")
  prefix.worst <- paste0(prefix, "_worst")
  brca.subset <- brca.x.normal[,c(prefix.mean, prefix.se, prefix.worst)]
  cat("--------", prefix, "--------\n")
  pca <- prcomp(brca.subset)
  exp_pc2_var <- sum(pca$sdev[1:2]^2/sum(pca$sdev^2))
  if (exp_pc2_var < 0.95) {
    cat("PC2 Cumulative Proportion of Variance:", exp_pc2_var, "\nNot Preforming dimentionality reduction\n")
    brca.reduce[[paste0(prefix, "_mean")]] <- brca.x.normal[,prefix.mean]
    brca.reduce[[paste0(prefix, "_se")]] <- brca.x.normal[,prefix.se]
    brca.reduce[[paste0(prefix, "_worst")]] <- brca.x.normal[,prefix.worst]
  }
  else{
    cat(prefix, ": PC2 Cumulative Proportion of Variance:", exp_pc2_var, "\nreplace", prefix,"mean, se and worst to PC1 and PC2\n")
    brca.reduce[[paste0(prefix, "_pc1")]] <- pca$x[,1]
    brca.reduce[[paste0(prefix, "_pc2")]] <- pca$x[,2]
  }
}
brca.x.reduce <- brca.reduce[,!(colnames(brca.reduce) %in% c("diagnosis"))]
```
Now we check the correlation matrix between the features in the reduced data
```{r corr after pca}
corrs <- cor(brca.x.reduce)
colnames(corrs) <- gsub("_", " ", colnames(corrs))
rownames(corrs) <- gsub("_", " ", rownames(corrs))
corrplot(corrs, method = "square", tl.col = "black", tl.srt = 45, sig.level = 0.05, type = 'lower', diag = FALSE)
```
During this analysis we will apply our methods over the raw data and the reduced version and examine if the reduced version will deliver better results.
To visually see the two data sets we plot t-SNE on both sets, and color the observations according to the disgnosis:
```{r}
library(Rtsne)
reduce.tsne <- Rtsne(brca.x.reduce,
  pca = FALSE, perplexity = 10,
  theta = 0.0
)
reduce.tsne <- data.frame(
  TSNE1 = reduce.tsne$Y[, 1],
  TSNE2 = reduce.tsne$Y[, 2],
  Diagnosis = brca$diagnosis)
p1 <- ggplot(reduce.tsne, aes(
  x = TSNE1, y = TSNE2,
  col = Diagnosis
)) +
  geom_point() + ggtitle("After dimantionality reduction") + theme(legend.position = "none")
full.tsne <- Rtsne(brca.x,
  pca = FALSE, perplexity = 10,
  theta = 0.0
)
full.tsne <- data.frame(
  TSNE1 = full.tsne$Y[, 1],
  TSNE2 = full.tsne$Y[, 2],
  Diagnosis = brca$diagnosis)
p2 <- ggplot(full.tsne, aes(
  x = TSNE1, y = TSNE2,
  col = Diagnosis
)) +
  geom_point()  + ggtitle("Before dimantionality reduction")
grid.arrange(p2, p1, widths=c(0.55, 0.45), ncol=2)
```


### supplementary Plots:
correlation between triplets of "mean", "se" and "worst".
```{r corr triplets plot}
for (prefix in measures) {
  # Find column names that start with the current prefix
  prefix.mean <- paste0(prefix, "_mean")
  prefix.se <- paste0(prefix, "_se")
  prefix.worst <- paste0(prefix, "_worst")
  brca.subset <- brca.x.normal[,c(prefix.mean, prefix.se, prefix.worst)]
  colnames(brca.subset) <- gsub("_", " ", colnames(brca.subset))
  cor(brca.subset) %>% corrplot(method = "square", tl.col = "black", tl.srt = 45, sig.level = 0.05, type = 'lower', diag = FALSE)
}
```
correlations between all the features that related to the shape of the tumor cells (radius, perimeter and area)
```{r corr shape plot}
colnames(brca.shape) <- gsub("_", " ", colnames(brca.subset))
cor(brca.shape) %>%
corrplot(method = "square", tl.col = "black", tl.srt = 45,
         sig.level = 0.05, type = 'lower', diag = FALSE)
```
For Guy and Shir:
the variable brca contains the whole dataframe in the raw shape
the variable brca.x contains only the numerical features (no diagnosis)
brca.x.normal is brca after min-max normalization
brca.reduce and brca.x.reduce are the dataframes after dimantionality reduction
Try every ML algorithm on both brca (or brca.x.normal if you want it noramlized) and brca.reduce
afterward we will see if the dimentionality reduction did helped.






